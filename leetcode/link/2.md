# åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

> ç®€ç­‰â­

**âš¡é¢˜ç›®**ï¼š

â“ å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ ã€Œå‡åºã€ é“¾è¡¨å¹¶è¿”å›žã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æŽ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚

è¾“å…¥ï¼š1->2->4, 1->3->4
è¾“å‡ºï¼š1->1->2->3->4->4

## æ€è€ƒ âŒš

- å‡åºé“¾è¡¨åˆå¹¶
- æ¯”è¾ƒå¤§å°ï¼Œå–å°çš„å€¼ï¼Œæ›´å°çš„å€¼æŒ‡å‘ä¸‹ä¸€èŠ‚ç‚¹
- æœ€åŽåˆ¤æ–­ å½“ä¸¤è€…å…¶ä¸­æœ‰ä¸€ä¸ªä¸ºç©ºæ—¶ï¼Œå³æŒ‡å‘å¦ä¸€ä¸ªå‰©ä½™

## å°è¯• âŒ›

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *    this.val = (val===undefined ? 0 : val)
 *    this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
function mergeSortLists(l1, l2) {
  let head = new ListNode('head');
  let temp = head;
  while (l1 && l2) {
    if (l1.val >= l2.val) {
      temp.next = l2;
      l2 = l2.next;
    } else {
      temp.next = l1;
      l1 = l1.next;
    }
    temp = temp.next; // æ›´æ–°
  }

  // åˆ¤æ–­æœ€åŽé“¾è¡¨ç©º
  temp.next = l1 === null ? l2 : l1;
  return head.next;
}
```

## ä¼˜è§£ ðŸš€

- é€’å½’æ€è·¯
- é€’å½’è§£æ³•è¦æ³¨æ„é€’å½’ä¸»é¢˜é‡Œæ¯æ¬¡è¿”å›žå€¼è¾ƒå°å¾—èŠ‚ç‚¹ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯æˆ‘ä»¬æœ€åŽå¾—åˆ°å¾—æ˜¯é“¾è¡¨å¾—æœ€å°å¼€å¤´
- é€’å½’å‡ºå£ï¼šä»»æ„ä¸€ä¸ªé“¾è¡¨ä¸ºç©ºæ—¶,ç›´æŽ¥return å¦å¤–ä¸€ä¸ªé“¾æŽ¥ï¼Œä¹Ÿå°±æ˜¯æ‹¼æŽ¥è¿‡ç¨‹
- ä»Žä¸¤ä¸ªé“¾è¡¨ä¸­ä¾æ¬¡å–å‡ºèŠ‚ç‚¹æ¯”è¾ƒï¼Œå°çš„é‚£ä¸€ä¸ªå°±æ‹Žå‡ºæ¥ä½œä¸ºä¸‹ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *    this.val = (val===undefined ? 0 : val)
 *    this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
function mergeSortLists(l1, l2) {
  if(l1 == null ) return l2
  if(l2 == null ) return l1
  if(l1.val > l2.val) {
    l2.next = mergeTwoLists(l1, l2.next)
    return l2
  }else{
    l1.next = mergeTwoLists(l1.next, l2)
    return l1
  }
}
```
